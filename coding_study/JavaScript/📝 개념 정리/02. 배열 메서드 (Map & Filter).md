# Map & Filter: 데이터 가공 공장 #

: "반복문(for) 대신 쓰는 데이터 가공 공장"

- 리액트에서는 `for` 문을 거의 안 쓴다. 
- 대신 '원본은 건드리지 않고, 새로운 배열을 만들어내는' `map` 과 `filter` 를 쓴다
	- 데이터를 화면에 뿌릴 때 무조건 `map` 을 쓴다. 

## 1. Map (변신시키기) ##

- 핵심: 배열의 모든 요소를 꺼내서, 내가 원하는 형태로 바꿔서 새로운 배열을 만든다
- 특징: 원본 개수 = 결과물 개수 (10개 넣으면 10개 나옴)
- 공식: `배열.map ( (꺼낸거) => 바꿀거 )`

- 상황: 서버에서 가져온 글 목록 (data) 을 화면에 보여줄 HTML 태그 (div)로 바꿀 때 쓴다. 
```js
const data = ["JS 공부", "리액트 기초", "운동"];

// 하나씩 꺼내서(item) <div>로 감싸라
const result = data.map(item => `<div>${item}</div>`);

// 결과: ["<div>JS 공부</div>", "<div>리엑트 기초</div>", "<div>운동</div>"]
```

- 상황: 인사이트 덱에 저장된 스터디 주제 3개를 화면에 보여줄 버튼으로 반들고 싶다.
```js
const topics = ["Javascsript", "React", "Git"];

// topics를 돌면서, 각 단어(t)를 <button> 태그로 감싸라!
// (방금 배운 화살표 함수가 여기서 빛을 발한다)

const buttons = topics.map((t) => "<button>" + t + "</button>");

console.log(buttons);
// 결과: ["<button>Javascript</button>", "<button>React</button>", "<button>Git</button>"]
```

포인트: 원본 topics는 그대로 있고, buttons라는 새로운 배열이 생겼다. 

---

==예시에서 보여주는 item과 t는 선언되지 않았는데 어떻게 사용할 수 있는거야?==

- 변수 선언이 아니라 **별명짓기**

1. Map 과 Filter는 공장장이다
	- `map` 이라는 공장장은 데이터가 담긴 박스(배열)을 가지고 있다.
	- 박스 안 물건을 하나씩 꺼내서 직원(화살표 함수)에게 건네줌
		- 이때, 공장장 (map)과 직원(화살표 함수)의 대화
		
			- **공장장** (Map): "자, 여기 첫 번째 물건 받으세요. 이 물건 가지고 작업 좀 해주세요."
			- **직원(화살표 함수)**: "네, 알겠습니다. 저는 지금 받은 이 물건을 **s**라고 부르면서 작업할게요."
			
		- 여기서 s는 직원이 그 순간에만 잠깐 붙인 임시 별명이다!

2. 내 마음대로 이름을 지어도 되는 이유
	- 직원(화살표 함수)이 건네받은 물건을 뭐라고 부르든 상관없음.
	- 어차피 지금 내 손에 들려있는 그 데이터를 가리키는 것

아래 세 코드는 다 동일:
```js
// 1. 별명을 'user'라고 지었을 때
users.map(user => user.name);

// 2. 별명을 u라고 지었을 때
users.map(u => u.name);

// 3. 별명을 'chicken'이라고 지었을 때 (이래도 작동한다!)
users.map(chicken => chicken.name);
```

- 방금 배열에서 꺼낸 그 데이터 ( { name: "Ingrid"...} ) 를 이 함수 안에서만 잠깐 chicken이라고 부르겠다는 뜻이다

3. 실제로 일어나는 내부 동작
	- 컴퓨터 내부에서 map이 돌아갈 때:
```js
const users = [{ name: "Ingrid" }, { name: "Y" }];

// 우리가 짠 코드: users.map(s => s.name)

// [실제로 컴퓨터가 하는 일]
// 1. 첫 번째 데이터({ name: "Ingrid" })를 꺼낸다.
// 2. 우리가 만든 함수 (s => s.name)한테 던져준다.
// 3. 이때 's' 자리에 첫 번째 데이터가 쏙 들어간다. 
//  ==> { name: "Ingrid" }.name (결과: "Ingrid")

// 4. 두 번째 데이터({ name: "Y" })를 꺼낸다
// 5. 다시 함수한테 던져준다.
// 6. 이번엔 's' 자리에 두 번째 데이터가 들어간다. 
// ==> { name: "Y" }.name (결과: "Y")
```

- 즉, s나 t는 지금 순서에 들어오는 데이터가 앉을 자리의 이름표

---
#### 요점 정리 ####
1. 선언 불필요: map이나 filter 괄호 안에 쓰는 단어 (s, t, item 등)는 매개변수 (Parameter)라고 하며, 따로 const 선언을 안 해도 된다.

2. 자유로운 작명: 이름은 아무거나 써도 되지만, 남들이 알아보기 쉽게 짓는 게 좋다. 
	- users 배열이면 → user
	- studies 배열이면 → study
	- todos 배열이면 → todo

3. 유효 범위: 그 이름은 화살표 함수(중괄호) 안에서만 살아있다. 밖에서는 못 쓴다. 

---
## 2. Filter (걸러내기) ##

- 핵심: 조건이 "참"인 녀석들만 살아남는다. (거짓이면 탈락/삭제) 
- 특징: 원본 개수 >= 결과물 개수 (걸러지니까 줄어들 수 있음)
- 공식: `배열.filter( (꺼낸거) => 살려둘_조건 )`

- 상황: '삭제' 기능을 구현할 때 쓴다. (ID가 3번인 글을 지워라 = ID가 3번이 아닌 것만 남겨라)
```js
const numbers = [1, 2, 3, 4, 5];

// 3보다 큰 숫자만 남겨라
const result = numbers.filter(num => num > 3);

// 결과: [4, 5]
```

- 상황: 스터디 목록에서 완료된(isDone: true)것만 남기거나, 특정 ID를 삭제하고 싶을 때 쓴다.
```js
const numbers = [1, 2, 3, 4, 5];

// 짝수만 살려라 (나머지가 0인 것)
const evens = numbers.filter((num) => num % 2 === 0);

console.log(evens); // [2, 4]
```

- 상황:  인사이트덱 - 공부 시간(time)이 3시간 이상인 것만 보고 싶다
```js
const studies = [
  { id: 1, subject: "JS", time: 2 },
  { id: 2, subject: "React", time: 5 }, // < - 얘만 살아야 함
];

// "시간(s.time)이 3보다 큰 녀석만 통과!"
const result = studies.filter(s => s.time > 3);

console.log(result);
// 결과: [{ id: 2, subject; "React", time: 5 }]
```

---
### Quiz 1 ###

상황: 당신은 인사이트 덱의 관리자 페이지를 만들고 있다. 
users 배열에는 회원 정보가 담겨 있다. 

1. Filter: 나이가 30세 이상인 회원만 고른다. 
2. Map: 골라낸 회원의 이름을 "VIP 회원: `[이름]`" 형태로 바꾼다. 

두 단계로 나눠서 생각하기:
```js
const users = [
  { name: "Ingrid", age: 32 },
  { name: "Y", age: 25 },
  { name: "Admin", age: 40 }
];

// 1단계: 30세 이상만 필터링 (정답을 적어봐라)
const olderUsers = users.filter(user => ________);

// 2단계: 필터링된 유저들의 이름만 VIP 명찰 달아주기 (정답을 적어봐라)
const vipLabels = olderUsers.map(user => _______);

console.log(vipLabels);
// 예상 결과: ["VIP 회원: Ingrid", "VIP 회원: Admin"]
```

답:
```js
const users = [
  { name: "Ingrid", age: 32 },
  { name: "Y", age: 25 },
  { name: "Admin", age: 40 }
];

const olderUsers = users.filter(user => user.age >= 30);

const vipLabels = olderUsers.map(user => "VIP 회원: " + user.name);
//또는 템플릿 리터럴 사용 시:
// const vipLabels = olderUsers.map(user => `VIP 회원: ${user.name}`)

console.log(vipLabels);

```

---

⚠️ 매번 `user.age`, `user.name`, `user.어쩌구` 치기 귀찮고 헷갈림
- **구조 분해 할당 (Destructuring)** 사용하면 된다

예시:
```js
// 구조 분해 할당을 쓰면 'user.'을 생략할 수 있다!
const olderUsers = users.filter(({ age }) => age >= 30);
```

---
### Quiz 2 ###

화살표 함수 + Map + Filter을 조합해서 '인사이트 덱'의 핵심 기능을 만들자. 

상황: todos 배열에는 오늘 할 공부 목록이 담겨 있다. 
1. Filter: 아직 완료하지 못한 (done: false) 공부만 골라내세요
2. Map: 골라낸 공부의 제목 (task)만 뽑아서, "할 일: `[제목]`" 형태로 바꾼다. 

```js
const todos = [
  { id: 1, task: "화살표 함수 복습", done: true },
  { id: 2, task: "Map/Filter 이해", done: false },
  { id: 3, task: "프로젝트 적용", done: false }
];

// 1단계: 안 끝난 공부만 필터링 (화살표 함수를 써보기)
const notFinished = todos.filter(todo => todos.done === false);

// 2단계: 필터링된 목록을 "할 일: ..." 문장으로 변신
const messages = notFinished.map(todo => );
```