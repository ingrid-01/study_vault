# 참조형 대이터와 얕은 복사의 함정 #

## 1. 핵심 요약: ##

- 객체 복사는 기본적으 "방 열쇠"만 복사해 주는 것
- 안에 또 객체가 있으면(e.g. urls), 그 안쪽 열쇠도 똑같이 복사된다 = 공유된다!
## 2. 나의 언어(비유): ## 

- "친구에게 내 물품 보관함 열쇠를 복사해줬다."
- "친구가 보관함에 들어와서 물건을 바꾸면, 나중에  내가 열었을 때도 바뀌어 있다."

### copyObject 코드 이해하기 ###

```js
var copyObject = function (target) {
    var result = {};  // 1. 새로운 빈 보관함(객체)을 하나 만듭니다.
    
    // 2. target(원본)에 있는 이름표(prop)를 하나씩 확인합니다.
    for (var prop in target) {
        // 3. 원본 이름표에 연결된 '값'을 그대로 가져와서 
        //    새 보관함의 같은 이름표에 붙여넣습니다.
        result[prop] = target[prop];
    }
    
    return result; // 4. 복사가 끝난 새 보관함을 반환합니다.
}
```

var copyObject = function (target) {
   var result = {};
   for (var prop in target) {
     result[prop] = target[prop]
   }
   return result;
}

---

### 얕은 복사의 한계점

`user` 객체 안에 `urls`라는 프로퍼티가 있었습니다. 우리가 `copyObject` 함수를 돌릴 때, 반복문이 `urls` 차례에 오면 이런 일이 벌어집니다.

JavaScript

```
result['urls'] = target['urls'];
```

**가이드 질문:** 우리가 앞서 **"참조형 데이터(객체)는 변수 공간에 값이 직접 들어가는 게 아니라 주소값(열쇠)이 들어간다"**고 배웠었죠?

그렇다면 위 코드에서 `target['urls']`를 `result['urls']`에 대입할 때,

1. `urls`라는 **객체 덩어리(내용물) 자체**가 복사되어 들어갈까요?
    
2. 아니면 `urls` 객체가 있는 방을 가리키는 **주소값(열쇠)**만 복사되어 들어갈까요?

방금 해석하신 코드 `result[prop] = target[prop]`는 **'값'**을 가져오라고 했죠?

그런데 우리가 1장 초반에 배웠듯, **참조형 데이터(객체)의 변수 공간에 들어있는 '값'은 무엇이었나요?** 데이터 자체가 아니라 **주소값(열쇠)**이었습니다.

---
### 🗝️ 얕은 복사의 실제 동작 (팩트 체크)

1. `urls`는 객체입니다. 그래서 `target['urls']` 자리에는 블로그 주소들이 들어있는 게 아니라, **`@5003` (urls 방 열쇠)**이 들어있습니다.
    
2. `result['urls'] = target['urls']`를 실행하면?
    
    - 새 보관함(`result`)을 만들긴 했습니다.
        
    - 하지만 `urls` 칸에는 **`@5003`이라는 열쇠만 복사**해서 넣은 것입니다.
        
3. **결과:** 원본(`target`)도 `@5003` 열쇠를 가지고 있고, 복사본(`result`)도 똑같은 `@5003` 열쇠를 가지게 됩니다.
    

즉, **새 보관함(`urls`)을 따로 만든 게 아니라, 같은 보관함을 여는 열쇠만 하나 더 복사한 셈**입니다. 그래서 한쪽에서 `@5003` 방을 열고 내용을 바꾸면 다른 쪽도 영향을 받는 것이죠.

---
### 2단계: 문제 해결 (깊은 복사)

자, 그럼 이 문제를 해결하려면 코드를 어떻게 고쳐야 할까요? **27페이지(예제 1-16)**에 나오는 **'깊은 복사(Deep Copy)'** 코드가 그 정답입니다.

이 코드는 `target[prop]`이 객체일 경우, 그냥 주소(열쇠)만 가져오는 게 아니라 **"어? 너 객체네? 그럼 나도 새 박스 만들어서 안의 내용물까지 싹 다 베껴올게!"** 라고 동작합니다.

**질문:** 27페이지 예제 1-16 코드를 보면, 함수 내부에서 **자기 자신을 다시 호출하는(재귀 호출)** 부분이 있습니다. 이 재귀 호출(`copyObjectDeep`)을 하는 이유가 무엇일까요? **어떤 조건**일 때 그냥 복사하지 않고 재귀 호출을 하나요?

(힌트: `typeof` 명령어로 확인하는 조건을 봐주세요!)