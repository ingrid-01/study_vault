# 01 데이터 타입의 종류 #
## 기본형 - 원시형 (Primitive Type) ##
- 숫자 number
- 문자열 string
- 불리언 boolean
- null
- undefined
- 심볼
---
### 기본형 ###
- 할당 + 연산시 복제 됨
	- 값이 담긴 주솟값을 바로 복제
- 불변성 (immutability)
	- 개략적 

## 참조형 - Reference Type ##
- 객체 object
- 배열 array
- 함수 function
- 날짜 date
- 정규표현식 RegExp
- Map
- WeakMap
- Set
- WeakSet
---
### 참조형 ###
- 참조됨
	- 값이 담긴 주솟값 묶음을 가리키는 주솟값을 복제

---
# 1-5-2 얕은 복사와 깊은 복사 #

## 1. 핵심 개념: 복사가 다 같은 복사가 아니다?

JS Object를 복사할 때 - 두 가지 방식
- 겉만 살짝 복사하는 **얕은 복사** 
- 속까지 완벽하게 복사하는 **깊은 복사**

- **얕은 복사** (Shallow Copy) → 바로 아래 단계의 값만 복사. 
	- 만약 객체 안에 또 다른 객체가 있다면, 그 내부 객체의 '주소값'만 복사
- **깊은 복사** (Deep Copy) → 내부의 모든 값들은 하나하나 찾아서 전부 복사.
	- 원본과 사본이 완벽하게 분리된다. 
---
## 2. 얕은 복사 (Shallow Copy)의 문제점 ##

초보자가 가장 많이 하는 실수는 얕은 복사를 해놓고 "복사했으니 원본은 안전하겠지?"라는 생각

- **현상**: 중첩된 객체(객체 안의 객체)를 얕은 복사하면, 원본과 사본이 내부 데이터를 공유하게 됨.

- **예시 상황**: user라는 객체를 복사해서 user2를 만들었다고 가정

- **문제 발생**: user2.name을 바꾸면 user2 만 바뀐다. 하지만 user2.urls.portfolio를 바꾸면 원본인 user.urls.portfolio도 같이 바뀌어 버림. 

- **이유**: urls 같은 내부 프로퍼티에 대해서는 원본과 사본이 **동일한 주소**를 가리키고 있기 때문. 즉, 사본을 바꿨는데 원본이 훼손되는 사고 발생. 
---
## 3. 해결책: 깊은 복사 (Deep Copy) 하는 방법 ##

객체 내부의 깊숙한 곳까지 완벽하게 복사해서, 원본과 사본을 완전히 남남으로 만들려면 **깊은 복사**를 해야 한다. 

두 가지 방법:

---
# 불변성 Immutability #

- 데이터가 생성된 이후 - 그 상태를 변경 할 수 없는 성질

### 핵심 메커니즘: 참조(Reference)와 값 ###
- 데이터를 변경하고 싶을 때, 메모리에 있는 기존 값을 직접 수정하는 것 X
- **새로운 값을 만들어내고** 그 곳을 가리키게(참조하게) 한다. 

### Mutable(변경 가능) 예시 ###
``` js
let user = { name: "Fred", age: 25};
user.age = 26; // 기존 메모리 영역의 값을 직접 26으로 변경함

console.log(user); // { name: "Fred", age: 26 }
// 문제점: 만약 다른 곳에서 'user' 객체를 보고 있었다면,
// 예고도 없이 값이 바뀌어 버린다. (Side Effect)
```
### Immutable (불변) 예시 ###
``` js
const user = { name: "Fred", age: 25 }; // user.age = 26; (X) 이렇게 하지 않음

// 기존 user를 복사하고, age만 덮어쓴 '새로운 객체'를 생성
cost updatedUser = { ...user, aged}
```