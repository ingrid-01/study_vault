# 01 데이터 타입의 종류 #
## 기본형 - 원시형 (Primitive Type) ##
- 숫자 number
- 문자열 string
- 불리언 boolean
- null
- undefined
- 심볼
---
### 기본형 ###
- 할당 + 연산시 복제 됨
	- 값이 담긴 주솟값을 바로 복제
- 불변성 (immutability)
	- 개략적 

## 참조형 - Reference Type ##
- 객체 object
- 배열 array
- 함수 function
- 날짜 date
- 정규표현식 RegExp
- Map
- WeakMap
- Set
- WeakSet
---
### 참조형 ###
- 참조됨
	- 값이 담긴 주솟값 묶음을 가리키는 주솟값을 복제

---
# 1-5-2 얕은 복사와 깊은 복사 #

## 1. 핵심 개념: 복사가 다 같은 복사가 아니다?

JS Object를 복사할 때 - 두 가지 방식
- 겉만 살짝 복사하는 **얕은 복사** 
- 속까지 완벽하게 복사하는 **깊은 복사**

- **얕은 복사** (Shallow Copy) → 바로 아래 단계의 값만 복사. 
	- 만약 객체 안에 또 다른 객체가 있다면, 그 내부 객체의 '주소값'만 복사
- **깊은 복사** (Deep Copy) → 내부의 모든 값들은 하나하나 찾아서 전부 복사.
	- 원본과 사본이 완벽하게 분리된다. 
---
## 2. 얕은 복사 (Shallow Copy)의 문제점 ##

초보자가 가장 많이 하는 실수는 얕은 복사를 해놓고 "복사했으니 원본은 안전하겠지?"라는 생각

- **현상**: 중첩된 객체(객체 안의 객체)를 얕은 복사하면, 원본과 사본이 내부 데이터를 공유하게 됨.

- **예시 상황**: user라는 객체를 복사해서 user2를 만들었다고 가정

- **문제 발생**: user2.name을 바꾸면 user2 만 바뀐다. 하지만 user2.urls.portfolio를 바꾸면 원본인 user.urls.portfolio도 같이 바뀌어 버림. 

- **이유**: urls 같은 내부 프로퍼티에 대해서는 원본과 사본이 **동일한 주소**를 가리키고 있기 때문. 즉, 사본을 바꿨는데 원본이 훼손되는 사고 발생. 
---
## 3. 해결책: 깊은 복사 (Deep Copy) 하는 방법 ##
