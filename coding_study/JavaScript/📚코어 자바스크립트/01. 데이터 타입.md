# 01 데이터 타입의 종류 #
## 기본형 - 원시형 (Primitive Type) ##
- 숫자 number
- 문자열 string
- 불리언 boolean
- null
- undefined
- 심볼
---
### 기본형 ###
- 할당 + 연산시 복제 됨
	- 값이 담긴 주솟값을 바로 복제
- 불변성 (immutability)
	- 개략적 

## 참조형 - Reference Type ##
- 객체 object
- 배열 array
- 함수 function
- 날짜 date
- 정규표현식 RegExp
- Map
- WeakMap
- Set
- WeakSet
---
### 참조형 ###
- 참조됨
	- 값이 담긴 주솟값 묶음을 가리키는 주솟값을 복제

---
# 1-5-2 얕은 복사와 깊은 복사 #

## 1. 핵심 개념: 복사가 다 같은 복사가 아니다?

JS Object를 복사할 때 - 두 가지 방식
- 겉만 살짝 복사하는 **얕은 복사** 
- 속까지 완벽하게 복사하는 **깊은 복사**

- **얕은 복사** (Shallow Copy) → 바로 아래 단계의 값만 복사. 
	- 만약 객체 안에 또 다른 객체가 있다면, 그 내부 객체의 '주소값'만 복사
- **깊은 복사** (Deep Copy) → 내부의 모든 값들은 하나하나 찾아서 전부 복사.
	- 원본과 사본이 완벽하게 분리된다. 
## 2. 얕은 복사 (Shallow Copy)의 문제점 ##

초보자가 가장 많이 하는 실수는 얕은 복사를 해놓고 "복사했으니 원본은 안전하겠지?"라는 생각

- **현상**: 중첩된 객체(객체 안의 객체)를 얕은 복사하면, 원본과 사본이 내부 데이터를 공유하게 됨.

- **예시 상황**: user라는 객체를 복사해서 user2를 만들었다고 가정

- **문제 발생**: user2.name을 바꾸면 user2 만 바뀐다. 하지만 user2.urls.portfolio를 바꾸면 원본인 user.urls.portfolio도 같이 바뀌어 버림. 

- **이유**: urls 같은 내부 프로퍼티에 대해서는 원본과 사본이 **동일한 주소**를 가리키고 있기 때문. 즉, 사본을 바꿨는데 원본이 훼손되는 사고 발생. 
## 3. 해결책: 깊은 복사 (Deep Copy) 하는 방법 ##

객체 내부의 깊숙한 곳까지 완벽하게 복사해서, 원본과 사본을 완전히 남남으로 만들려면 **깊은 복사**를 해야 한다. 

==두 가지 방법:==

**방법 A** - 재귀 함수 이용 (정석 방법)
- 함수 내부에서 "이 값이 객체인가?"를 확인하고, 객체라면 그 함수 자신을 다시 호출(재귀)하여 끝까지 파고들어 복사하는 방식입니다

- **원리**: target이 객체인 경우 내부 property들을 순회하면 copyObjectDeep 함수를 재귀적으로 호출한다. 객체가 아닌 기본형 데이터일 때만 값을 그대로 복사한다. 

- **장점**: 원본 객체의 구조를 완벽하게 유지하며 복사할 수 있다. 

**방법 B** - JSON 변환 이용 (간단한 꿀팁)
- 객체를 문자열 (JSON)로 싹 바꿨다가, 다시 객체로 바꾸는 방법

**코드**:
- **원리**: 객체를 JSON 문법의 '문자열'로 전환했다가 다시 JSON 객체로 바꿈
- **장점**: 짧고 간결한 코드
- **치명적인 단점**:
	1. 함수(method)는 복사되지 않고 사라진다
	2. __ proto __ 나 getter/setter 같은 숨겨진 property도 무시된다
	3. 데이터 안에 undefined나 function이 있으면 복사되지 않는다

## 요약 ##

1. 얕은 복사 
	- 겉표지만 복사
	- 내용물(중첩된 객체)는 원본과 공유되므로 수정 시 **원본이 훼손될 이험**이 있다.
	
2. 깊은 복사
	- 내용물까지 새로 써서 완벽한 사본을 만드는 것.
	- 참조형 데이터가 있을 때마다 재귀적으로 복사를 수행해야 한다

3.  실무에서 **순수한 데이터(Http Request로 받은 데이터 등)** 를 복사할 때는 JSON.parse(JSON.stringfy(..))를 쓰면 가장 간편하게 깊은 복사를 할 수 있다. 
	- 단, 함수나 숨겨진 속성은 복사되지 않음을 명심해야 합니다. 
---
# 불변성 Immutability #

- 데이터가 생성된 이후 - 그 상태를 변경 할 수 없는 성질

### 핵심 메커니즘: 참조(Reference)와 값 ###
- 데이터를 변경하고 싶을 때, 메모리에 있는 기존 값을 직접 수정하는 것 X
- **새로운 값을 만들어내고** 그 곳을 가리키게(참조하게) 한다. 

### Mutable(변경 가능) 예시 ###
``` js
let user = { name: "Fred", age: 25};
user.age = 26; // 기존 메모리 영역의 값을 직접 26으로 변경함

console.log(user); // { name: "Fred", age: 26 }
// 문제점: 만약 다른 곳에서 'user' 객체를 보고 있었다면,
// 예고도 없이 값이 바뀌어 버린다. (Side Effect)
```
### Immutable (불변) 예시 ###
``` js
const user = { name: "Fred", age: 25 }; // user.age = 26; (X) 이렇게 하지 않음

// 기존 user를 복사하고, age만 덮어쓴 '새로운 객체'를 생성
const updatedUser = { ...user, age: 26 };

console.log(user);        // { name: "Fred", age: 25 };
console.log(updatedUser); // { name: "Fred", age: 26 };
```

## Why? ##

**1. 예측 가능성 (Predictability:)**
- 데이터가 어디선가 몰래 바뀌지 않습니다. user 변수가 생성될 때의 값 그대로 유지됨을 보장받으므로 코드를 읽고 디버깅하기 훨씬 쉬워짐. 

**2. 부수 효과(Side Effect) 방지:**
- 함수에 객체를 전달해을 때, 그 함수가 내 객체를 마음대로 조작해서 원본을 훼손할까 봐 걱정할 필요가 없다. 

**3. 변화 감지 (Change Detection) 속도 향상:**
- React 같은 라이브러리에서 중요!
- 객체의 내용물을 하나하나 뜯어서 비교 (Deep Compare) 할 필요 X
- '메모리 주소(참조)가 바뀌었나?' → 확인만 하면 됨 = 빠른 성능

**4. 멀티스레드 안정성 (Thread Safety):**
- 여러 스레드가 동시에 같은 데이터에 접근해도, 데이터가 수정되지 않기 때문에 락(Lock)을 걸거나 동기화 문제를 크게 걱정할 필요 X

### 단점 + 해결책 ###
- 단점: 매번 새로운 객체를 만드니 메모리를 많이 씀 + 성능이 느려짐
- 해결책:
	- 구조적 공유 Structural Sharing: 똑똑한 라이브러리 (Immutable.js, Immer 등)나 언어차원의 최적화는 객체 전체를 진짜로 다 복사하지 않습니다. 변경되지 않은 부분은 **기존 메모리를 재사용(공유)**하고, 변경된 노드만 새로 만듦
	- 생각보다 비용 적음

## 요약 ##
- 불변성: 한 번 만든 데이터는 절대 수정하지 않는다. 바꿀 땐 복사본을 만든다.
- 이유: 코드의 흐름을 예측하기 쉽고, 버그를 줄이며, 특히 리액트 같은 프레임워크에서 성능 최적화에 유리하다. 