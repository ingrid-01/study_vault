- `flex: 1;` = grow, shrink; equally fill the available space
- BUT for arranging items w SPECIFIC SIZE, we need ↓ 
# Alignment #
```css
.container {
  height: 140px;
  padding: 16px;
  background: plum;
  border: 4px solid indigo;
  display: flex;
  justify-content: space-between;
}

.item {
  width: 60px;
  height: 60px;
  border: 4px solid darkslategray;
  background: skyblue;
  flex: 1;
}
```

→ `flex: 1;` in `.item` = items fills the whole area, so width is ignored and stretched out

→ `justify-content: space-between;` = items inside the container keeps its width, so each items are spread out, leaving some gap in-between

`justify-content` = aligns items across the **main axis** 
`align-items` = align-items along **cross axis**
∴ `justify-content: center;` and `align-items: center;` will place items in the center of the WP

# Gap #
`gap: (value)` = Adds specific space btw flex items (similar to margin) 

## Additional Resources: An Interactive Guide to Flexbox ##
- CSS Grid vs. Flexbox
	- we should know both layouts as they solve different problems
	- Flexbox is best for dynamic, fluid UIs 
### Flex Direction ###
children positioning rules:
1. **Primary axis** : Children will be bunched up at the start of the container
2. **Cross axis** : Children will stretch out to fill the entire container
### Alignment ###
`flex-direction: (value)`
- column 
- row

`justify-content: (value)`
- flex-start
- center
- flex-end
- space-between
- space-around
- space-evenly

`align-items: (value)` (GROUP of flex items within the same container)
- stretch
- flex-start - aligns the top-edge of the flex item
- center
- flex-end
- baseline - aligns the bottom-line (text alignment)

`align-self` → applied to the *child element* (ONE flex item)
	- changes alignment of a SPECIFIC child along the cross axis
	- SAME VALUES as `align-items`
#### Content vs. Items ####
- Contents → like a kebab skewer, needs to move together
	- this is in the primary axis
	- Only can distribute group
- Items → like cocktail wieners, can move separately
	- this is in the cross axis
	- Can do what the fuck it wants

`justify` - position something along the primary axis
`align` - position something along the cross axis
`content` - a group of "stuff" that can be distributed
`items` - single items that can be positioned ind. 
### Hypothetical Size ###
- Flow Layout → `width` = hard constraint
- Flexbox → `width` = more of a suggestion, *hypothetical size* 
	- so if the child has a bigger width than its parent, the child will reduce accordingly to fit

==CSS is a collection of Layout Modes==
### Growing and Shrinking ###

`flex-basis` → it's same as `width` in Flex row; same as `height` in Flex column
- BUT not always, e.g. images
	- also, `width` can reduce an item below its MINIMUM size, `flex-basis` can't

`flex-grow` default = 0
- growing = opt-in system
- multiple children with `flex-grow` = space is shared among them
- with no `flex-grow` → both children shrink to minimum comfortable size + extra space ≠ distributed

`flex-shrink` 
- used when children are TOO BIG for their container
- each child shrinks proportionally
	- bigger child will have x n the width of smaller child
	- absolute values don't matter, if `flex-shrink` value is given, that's what the browser will follow
	- ==it's all about the ratio==
	- `flex-shrink` = inverse `flex-grow`
		- `flex-grow` → controls extra space distribution when items are smaller than the container
		- `flex-shrink` → controls space removal when items are bigger than their container
		- ∴ only one of these properties can be active at once

`flex-basis` and `width` = both sets the hypothetical size
BUT if we *don't* want our elements to scale down proportionally = use `flex-shrink`
### Preventing Shrinking ###
- SVG icons & shapes 
	- put `flex-shrink= 0;`= OPT-OUT mode
		- this sets `flex-basis` or `width` as hard minimum limit
	- this will keep its original shape
### The minimum size gotcha ###
- when container shrinks below a certain point = **content overflow**

- Another size to take consideration:
	- **the minimum size**

- Flexbox algorithm = doesn't shrink below minimum size
	- minimum text inputs - default of 170px - 200px (varies btw browsers)
	- element containing text → min. width = *longest unbreakable string of characters*
- To redefine min. size with `min-width` = set `min-width: 0px;` on the Flex child
	- overwrites "built-in" min-width
	- same with `min-height` when in Flex Column mode

	↳ BUT use with caution
	- e.g. items w long words, they'll still stay the same = other items will overlap when container shrinks
![[flexboxminwidth_example_20250801_1547.png]]

### Gap ###
- implemented to all modern browsers in 2021
#### Auto Margins ####
`margin: auto;`
- it uses the extra space + apply it to the element's margin
- treats the extra space as a *resource* + we decide exactly where it should go
### Wrapping ###
`flex-wrap: wrap;` = 2 or more rows of stuff
	within each row, `align-items` allows ind. child to move ↓ and ↑ 
- BUT it's in a single Flex context = cross axis intersect 2 rows = rows can't be moved ind., they need to be distributed 
	- to do this = `align-content`
## Additional Resources: MDN Typical use cases of flexbox ##

### Why use Flexbox ###
- one dimensional layout (row or column, not both - that's Grid)
- Easy centering
- Auto-distribution of space
- Easy reordering
- Equal-height columns (w/o JS)

1.  Navigation panel: 
- if I want Logo on the left, links in the centre, Login to the right ↓ 
```css
nav {
	display: flex;
	justify-content: space-between;
	align-items: center;
}
```

2. Vertically Centred Anything
- to center the content BOTH vertically and horizontally
```css
.container {
	display: flex;
	align-items: center;
	justify-content: center;
}
```

3. Equal-Height Columns
- all equal height children incl. media
```css
.container {
	display: flex;
}
.child {
	flex: 1;
}
```

4. Sticky Footer
- PUSH footer down
```css
body {
	display: flex;
	flex-direction: column;
	min-height: 100vh;
}
main {
	flex: 1;
}
```

5. Sidebar Layout
- sidebar w fixed width + content that fills the rest
```css
.container {
	display: flex;
}
.sidebar {
	width: 200px;
}
.content {
	flex: 1;
}
```

6. Flexible Rows that wrap
- tile/cards that adapt to screen size
```css
.container {
	display: flex;
	flex-wrap: wrap;
	gap: 1rem
}
.card {
	flex: 1 1 200px;
}
```

| I want                       | Flexbox                    |
| ---------------------------- | -------------------------- |
| "I want it centered"         | `align` and `justify`      |
| "Why are my items squished?" | `flex-grow, shrink, basis` |
| "Make it responsive"         | `wrap, min-width`          |
| "Just space things out"      | `space-bewteen, gap`       |
## Additional Resource: CSS Flexbox Layout Guide ##
- Flexbox - best for small scale layout
- CSS Grid - best for large scale layout

### Prefixing Flexbox ###
- Vendor prefixing 
	- used for browsers to check for compatibility
	- e.g. Chrome, Safari = `-webkit`; Firefox = `-moz-`; Internet Explorer = `-ms-`
- Prefixing occurred due to early ver. not able to understand new syntax + prefixes

e.g.
```css
display: -webkit-box; /* 2009 spec (old WebKit) */
display: -ms-flexbox; /* 2011 spec (IE10) */
display: flex; /* Final Standard */

-webkit-box-orient: horizontal; /* 2009 syntax */
-webkit-box-direction: normal; /* 2009 syntax */
-ms-flex-direction: row; /* IE10 */
flex-direction: row; /* Standard */
```

BUT in 2025 **DO NOT NEED** to manually add vendor prefixes for Flexbox *most of the time*
	1. all major browsers support the final Flexbox spec
	2. Autoprefixer - handle prefixes automatically

==When should I care?==
Only when:
1. targeting OLD browsers (IE10/11, old Android)
2. building for embedded systems or legacy clients
↳ Otherwise, don't wast time writing them by hand

Autoprefixer = PostCSS plugin
- adds vendor prefixes based on my defined browser support

It can: 
- build tools like `webpack`, `vite`, or `gulp`

```css
.container {
	disply: flex;
	flex-direction: row;
}
```
automatically becomes:
```css
.container {
	display: -webkit-box;
	display: -ms-flexbox;
	display: flex;
	-webkit-box-orient: horizontal;
	-webkit-box-direction: normal;
	-ms-flex-direction: row;
	flex-direction: row;
}
```

### Examples ###
1. Perfect Centering
```css
.parent {
	display: flex;
	height: 300px; /* Or chosen value */ 
}
.child {
	width: 100px; /* Or chosen value */
	height: 100px; /* Or chosen value */
	margin: auto;
}
```
- `margin: auto;` - in a flex container absorb extra space from all 4 directions 
	- ∴ make item perfectly centered in both axes

==Use `margin: auto;` in flex container to CENTER a SINGLE ITEM both vert. and horiz. w/o using `justify-content` and `align-items`==

```css
.flex-container {
/* We first create a flex layout context */
	display: flex;

/* Then we define the flow direction
	and if we allow the items to wrap
 * Remember this is the same as: 
 * flex-direction: row;
 * flex-wrap: wrap; 
 */
	flex-flow: row wrap;
	
/* The we define how is distributed the remaining space */
	justify-content: space-around;
}
```

2. Right-aligned navigation on Top; Centered on med-sized screen + single-columned on small screen
```css
/* Large */
.navigation {
	display: flex;
	flex-flow: row wrap;
	/* This aligns items to the end line on main-axis */
	justify-content: flex-end;
}	

/* Medium screens */
@media all and (max-width: 800px) {
	.navigation {
	/* When on meidum sized screens, we center it by evenly distributing empty space around items */
		justify-content: space-around;
	}
}

/* Small screens */
@media all and (max-width: 500px) {
	.navigation {
	/* On small screens we are no longer using row direction but column */
		flex-direction: column;
	}
}
```

3. Mobile-first 3 -columns layout w Full-width header & footer + independent from source order
```css
.wrapper {
	display: flex;
	flex-flow: row wrap;
}

/* We tell all items to be 100% width, via flex-basis */
.wrapper > * {
	flex: 1 100%;
}

/* We rely on source order for mobile-first approach in this case: 
	* 1. header
	* 2. article
	* 3. aside 1
	* 4. aside 2
	* 5. footer
*/

/* Medium screens */
@media all and (min-width: 600px) {
	/* We tell both sidebars to share a row */
	.aside {flex: 1 auto;}
}

/* Large screens */
@media all and (min-width: 800px) {
	/* We invert order of first sidebar and main
	And tell the main element to take twicse as much width as the other two sidebars
	*/
	.main  { flex: 3 0px; } 
	.aside-1  { order: 1; }
	.main     { order: 2; }
	.aside-2  { order: 3; }
	.footer   { order: 4; }
}
```
↳ `>` = child combinator 
- SO all direct children of `*` w. class `.wrapper`
- DOESN'T apply to nested (grandchildren, etc.) elements