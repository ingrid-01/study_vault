# Computer Basics #
## What is a Computer?##
- computer = store, retrieve and process data
	- electronic device that manipulates data
### Hardware vs. Software ###
- **Hardware** = physical structure
	- keyboard, mouse, monitor & internal parts
- **Software** = set of instructions for the hardware to process (what & how)
	- web browsers, games, word processors
- computer relies on BOTH software and hardware
### Different Types of Computers ###
- desktop, laptop, ATM, self-checkout, calculator, wearables, game consoles, TVs
- Servers → computer that serves info to other computers on the network
	- businesses use local file servers to store & share data internally
### PCs & Macs ###
- PCs
	- OG IBM PC → introduced in 1981
	- Most has Microsoft Windows OS
- Macs
	- Macintosh → introduced in 1984
	- has GUI (graphical user interface)
	- made by Apple and use Mac OS X
## What is an Operating System? ##
- OS = most important software
	- computer's memory and process manager
	- communicates w the computer
### OS jobs ###
- manages software & hardware
- all diff. comp. programs running simultaneously need to access **Central processing unit (CPU), memory and storage** 
	- OS coordinates ↑
### OS types ###
- usually pre-loaded on any comps.
- 3 most common OSs:
	- Microsoft Windows
	- macOS
	- Linux
- Modern OS use GUI
	↳ GUI = lets mouse click icons, buttons, menus and everything clearly displayed on screen using a combination of *graphics* and *text*
	- Each OS's GUI looks different
#### MS Windows ####
- Microsoft created Windows OS in mid-1980s
	- most recent = Windows 10 (2015 release)
- most popular OS in the world
#### macOS ####
- previously known as OS X
	- updated regularly, current - Sequoia (2024 release)
- macOS users → less than 10% globally
#### Linux ####
- open-source OS
	- can be modified, distributed by anyone
	- different to **proprietary software** (company owned & only modified by the comp.)
	- FREE to use, diff. variations available
- less than 2% users globally BUT most servers run Linux
### OS for Mobile devices ###
- for phones, tablet computers, MP3 players etc. 
	- Apple iOS or Google Android
## What is an application? ##
- App (application) = type of software to perform **specific** tasks
	- Desktop applications for desktop & laptops
	- Mobile apps for mobile devices
### Desktop Applications ###
- full featured
	- Word processors: MS Word
	- Web Browsers: IE, Mozilla Firefox, Google Chrome, Safari
	- Media players: Windows Media Player, iTunes
	- Games: Solitaire, Halo
- one or two tasks
	- Calendar, Clock apps
### Mobile Applications ###
- E.g. Gmail, Instagram, Duolingo
## Open source vs. Closed source software ##
- All comp. softwares are created using **source code** (technical blueprint)
	- if this is released to public = either open source or closed source
### Open Source ###
- publicly available
- programmers can read/change code
- Closed source softwares are most common BUT open source options of closed sources are often available
	- e.g. instead of MS office = LibreOffice
- Lack of tech support BUT public collab available to improve software
	- also, not as user friendly
### Closed Source ###
- a.k.a. proprietary software
- source code unaccessible + public can't modify
- Most common 
- stable, focused product BUT costs money
# How Does the Web Work? #
## How does the Internet Work? - BBC Documentary (2019) ##
- ARPANET
- distinguishing good & bad info. is a real world problem
## How Does the internet work? ##
- internet = backbone of the Web
	- 1960s - US army-funded research project 
	- 1980s - public infrastructure
- ISP = internet service provider
Web page
- document displayed on browser
- BOOKS IN THE LIBRARY
Website
- A collection of web pages → a single resource
- DIFF. SECTIONS OF THE LIBRARY (science, literature, philosophy)
Web server
- computer hosting a WS on internet
- LIBRARY
Web service
- software needing internet to perform function + provide data
Search Engine
- a web service that finds other Web pages
	- Google, Bing
- SEARCH INDEX IN THE LIBRARY
## How the web works ##
### Client and Servers ###
- comps connected to internet = client or server
	- client → requests
	- server → responses
- For client and server to connect, you need:
	- internet connection
	- TCP/IP
		- Transmission Control Protocol & Internet Protocol
	- DNS 
		- Domain name System
		- address book
			- Real web addresses (URLs - Uniform Resource Locators) = `192.0.2.172` = IP address = hard to remember
			∴ Domain name = e.g. mozilla.org = easier to remember

URL main parts:
> `https://developer.mozilla.org/en-US/`
- `https` 
	- **protocol** - used to send request
	- https = secure version of http = pretty much a default too most WSs
- `developer.mozilla.org`
	- domain name of URL = `developer` → **subdomain**
	- `mozilla.org` → **domain**
		- other subdomains can be: e.g. `support.mozilla.org` 
- `en-US`
	- **path** to resource - mozilla keeps US English content in one folder (en-US)

	- HTTP
		- Hypertext Transfer Protocol
		- defines language btw client & server
			- simple language of verbs. e.g.:
				- `GET` , `HEAD`, `POST`

Example: request for MDN home page
```http
GET /en-US/ HTTP/2

Host: developer.mozilla.org
```
↓ Response:
```http
HTTP/2 200

date: Tue, 11 Feb 2025 11:13:30 GMT
expires: Tue, 11 Feb 2025 11:40:01 GMT
server: Google frontend
last-modified: Tue, 11 Feb 2025 00:49:32 GMT
etag: "65f26b7f6463e2347f4e5a7a2adcee54"
content-length: 45227
content-type: text/html

<!doctype html> ... (the 45227 bytes of the requested web page HTML)
```
Explanation:
- `HTTP/2 200` 
	- HTTP/2 = version of HTTP
	- 200 = status code - request successful
		- Other status codes:
			- `301` - requested resource permanently moved to new location = redirecting content
			- `400` - server can't process the request; server can't understand format or error found
			- `403` - access not granted = when server knows who client is + client doesn't have permission
			- `404` - requested resource not found = wrong URL or content deleted w/o redirection
			- `503` - request can't be handled due to server problem = server is offline for maintenance
- `date`, `expires` etc.
	- HTTP headers = info about response
- `<!doctype html>`, etc.
	- response body = in this case, MDN homepage HTML doc

-  Assets
		- collective term for imgs, music, vids, word docs, PDFs etc. that AREN'T codes
### Steps ###
1. Browser goes to DNS server → finds real address
	##### DNS Request Steps #####
	1. type URL in browser
	2. browser checks DNS cache → user have already accessed the IP address before, browser negotiates w web server
	3. BUT if first time accessing this IP address = browser asks DNS server if DNS matches IP first
2. Browser sends an HTTP request msg to server for the WS for client
	1. this msg + other data sent btw client & the server → sent across internet connection using TCP/IP
3. server approves request → sends "200 OK" msg = "fo sho, check that WS out, girlie" → sends WS files to browser via data packets
	1. Data packets = data broken into small chunks
		1. small chunks = easier & quicker to replace if there's a problem
		2. small chunks = can be routed along diff. paths = exchange is faster & higher lvl of accessibility btw many users
4. browser assembles packets and voila!
# Installation Overview #
- Web Development Environment Set-Up
	- In-browser code editor OR "sandboxes"
		- gives tools & programs for accomplishing task at hand, nothing else = *so like a convenient way to process tasks* = ==shortcut to code==
		- Will be using some throughout TOP but BEST way to learn = operate in a real dev environment
## OS Options ##
*distros* = distributor / distributed ver., esp. for Linux
### macOS ###
- TOP supports Unix-based system 
	- **Unix**
		- 1970s, AT&T's Bell Labs wrote OS called Unix - wasn't commercial product
		- Uni of Cali produced → BSD (Berkeley Software Distribution) by modifying OG Unix
		- 1980s - AT&T and Bell broke up, AT&T ended up with Unix
		- 1990s - a Finnish guy wrote a kernel, Linux
		- ∴ Unix-like platform = GNU/Linux
- will need to install a few programs but no worries
### Linux (official Ubuntu flavors) ###
- free & open-source OS works well w all programming langs.
	- most dev tools are written to work natively w Linux
	- Ubuntu = one of most popular & user-friendly distributions available (lighter weight alt. to Xubuntu)
- if not Mac, use Linux
### Windows ###
- **not natively supported by TOP**
	- Recommended to:
		- a VirtualBox Virtual Machine = emulates comp. that runs within your existing OS
			- so OS within an exisiting OS
	- Dual-boot Ubuntu installation = installing 2 OS on your comp.
		- faster operation BUT risk of changing your hard drive partitions
			- need to take time to read instructions carefully
		- can access full capabilities of hardware, clean & distraction-free environment + learn platform used by many devs & servers
	- Windows Subsystem for Linux (WSL2) = can run full-fledged Linux environment from within an existing Windows installation process
		- ver 2. used in TOP = WSL2
### Reasons install Linux ###
- **Tested**
- **Community Support**
- **Development Tools are build for Linux**
	- Ruby on Rails & Node.js **expect** to run on an open-source (UNIX-based) platform like Linux
- **Work like the Pros**
- **Performance**
	- performance is priority = Linux occupies less hard drive space + uses fewer system resources than Windows
---
#### Linux is, also, ####
1. has a powerful Command-Line Interface
	- CLI provides high lvl of control & precision
		- Unlike GUIs (Graphical user interfaces) → interacts w ==text-based commands== 
			- ↳ this makes complex tasks like: software installation, system configuration, file management easier
			- also supports automation & scripting
2. Secure
	- has secure boot process, only trusted codes to be executed
	- uses user-based permissions + only allows control which has granted permissions
	- supports secure communication protocols 
		- e.g. HTTPS, SSH
	- incls. security-related tools
		- firewalls, intrusion detection systems, security-focused software packages
3. Highly customisable
	- supports wide range of shell systems
4. Receives consistent updates
	- frequent & stable updates
5. Wide range of Options
	- provides numerous distributions OR **distros**
		- such as:
			- *Ubuntu* - user-friendly; lrg comm of devs; good choice for new devs; pre-installed tools & libraries (Python, Ruby & Git)
			- *Fedora* - comm driven providing advanced tech & dev-friendly features; good choice for experienced devs
			- *Debian* - reliable & secure; good choice for devs seeking stability
			- *Linux Mint* - based on Ubuntu, user-friendly; good choice for devs all lvls
			- *Arch Linux* - minimalist; complete system control + latest development tools
6. has Strong Community Support
7. Lightweight
8. Developer-friendly
	- incl. development tools such as integrated development environments (IDEs), text editors, version control systems
9. Everywhere!
# Text Editors #
- MS Word  & LibreOffice Writer = *rich* text editors = unsuitable for coding
- Plain text editors - e.g. VS Code & Sublime = don't save additional info
	- saves only texts to read & execute file as code
## Code Editors ##
- **VS Code** (Visual Studio Code)
	- great add-on-support & Git integration
	- Most popular 
# Command Line Basics #
- blank window with a prompt and blinking cursor = command line interface (CLI)
## Introducing Shell ##
- most common way to interact w PCs = GUI (graphical user interface)
	- intuitive to learn BUT delivering instructions to comp. scales poorly
	- ∴ Unix shell = both **CLI** and scripting language
		- allows complex + repetitive tasks to be completed automatically & fast
### The Shell ###
- Shell = program where user can type commands
	- most popular shell and/or default shell = BASH (Bourne Again SHell)
- Shell grammar = allows combination of existing tools into powerful piplines & handle large volumes of data automatically
	- sequences of commands - written into a *script* = improves reproducibility
- Command line = easiest way to interact w remote machines + supercomputers
	- so you gotta learn shell, no buts
- shell uses a prompt: `$` or `%`
	- prompt = waiting for input
	- *don't type the prompt* when commanding
	- press `Enter` to execute
	- before the prompt, by default it also shoes: user name and host name
- `ls` → listing
	- lists content of current directory
## Navigating Files and Directories ##
- File System = OS responsible for managing files & directories (folders)
- `pwd` = print working directory: shows where you are

**Home Directory**
- `/` = in front of a file, it refers to root directory; inside a path, is a separator

To see contents for our own filesystem:
`$ man ls` → read its manual

`cd` = same as double clicking a folder 
	change directory; doesn't changes directory, it changes shell's current working directory
	↳ changes shell's settings for what directory we are in
	- ==BUT when `cd` command is given on its own = return to home directory==

`..` = parent of the current directory 
`.` = current directory

`-a` = show all
`-F` = classify the output
	- / (forward slash) → indicates directory
	- @ → indicates link
	- * → indicates an executable

`-l` = last changed date
`-r` = `ls -r` list items of directory in reverse order
`-t` = `ls -t` list items by time of last changed
`ls -rt` = useful to find most recent edits / if new output is written

When combining commands, `-` and spaces aren't required. 
So `ls -F -a` = `ls -Fa`

`~` → current user's home directory
	↳ /Users/lisakoh can be replaced w `~` 
	e.g. `% cd ~/Desktop/shell-lesson-data`

`-` → previous directory
	↳ `% cd -` = back in starting directory
		- going back and forth from one directory to another, very efficient
	`% cd ..` = brings you up a file
#### Absolute Path ####
- searching from the entire path from the root directory = use `/`
- e.g. `% cd /Users/lisakoh/Desktop/shell-lesson-data`

### General Syntax of a Shell Command ##
`% ls -F /`
- `%` → Prompt
- `ls` → Command
	- can have more than 1 option & 1 argument
	- BUT doesn't always require an argument or an option
- `-F` → Option
	- ==single== - is a short option; ==double== -- is a long option
	- change beh. of a command 
	- a.k.a switches or flags
- `/` → Argument
	- tell the command what to operate on (e.g. files and directories)
	- a.k.a. paramenters

spaces and capitalisation = IMPORTANT
- `ls -F` is a working command, `ls-F` isn't
- `ls -s` displays file sizes & directories with names, `ls -S` sort files & directories by size

∴ `ls [path]` → listing of file/directory
	`ls` on it's own = current working directory
`cd [path]` → changes current working directory = goes inside the path
## Working w Files and Directories ##
### Creating Directories ###
1. See where we are & what we already have
	1. `% pwd`
	2. `% cd exercise-data/writing/`
	3. `% ls -F`
2. Create a Directory
	1. `% mkdir thesis`
		1. make directory + name it thesis = creates a new folder called thesis in GUI
	2. OR `% mkdir -p ../project/data ../project/results`
		1. `-p` make directory w nested subdirectories in a single operation
	3. `% ls -FR ../project`
		1. `-R` with `ls` commands to list ALL nested subdirectories within a directory
			1. so `/data` and `/results` in  `/projects` 

> **Good Names for Files and Directories**
> 1. Don't use spaces
> 	1. use - or _ 
> 2. Don't begin the name with -
> 	1. cuz commands read it as Options
> 3. Stick w letters, numbers, . (period), - (dash) and _ (underscores)
### Create a Text File ###
If wanting to create a text editor called Nano on Thesis directory:
1. `% cd thesis`
	1. this makes us go to `thesis` directory
2. `% nano draft.txt`
	1. this creates a txt file inside `thesis`

**Text Editor** → only work w plain character data; no tables, imgs, other human-friendly media
- text editor used for practice here ≠ powerful, flexible
	- most programmers use Emacs or Vim (requires more time to learn)
	- OR graphical editor like Gedit or VScode

3. type whatever I need on the text editor
4. Then press `Ctrl` + `O` to write out data to disk = save as
	1. then default name is suggested which we can change or press `Return` to accept
5. Press `Ctrl` + `X` to quit editor and return to the shell

> Control = Ctrl = ^

**another way of creating a txt file**
1. `% touch [my_file].txt`
	1. `touch` command generates new txt file in current directory
	2. `ls -l` → inspects file (size, created date and time, name)
- Useful when using programs that requires empty files first

**Remove files**
`% rm my_file.txt`
↳ `rm` = remove
==IMPORTANT==
- Unix shell doesn't have a trash bin ≠ recover file
- Deleting on shell is deleting forever
- `% rm -i thesis_backup/quotations.txt`
		↳ `-i` option can be used to prompt `y` or `n` confirmation before deleting
- Directories cannot be deleted w `rm` option
	- need to use `% rm -r -i thesis`
		- `-r` for recursive option + `-i` for confirmation

`.txt` → txt file
`.pdf` → PDF file
`.cfg` → configuration file; contains parameters for some program
`.png` → PNG img
### Moving Files & Directories ###
- renaming file
	- `% mv thesis/draft.txt thesis/quotes.txt`
		- `mv` = move; commands rename
		- so `% mv [current file name] [desired file name]`
==IMPORTANT==
- `mv` overwrites with no confirmation SO be careful
- `mv -i` or `mv -interactive` causes request for confirmation
- `mv` works for both files and directories

- moving file to **another directory**
	- `% mv thesis/quotes.txt .`
		- "moves" `quotes.txt` file to `.` (current directory, which was in `/writing`)
### Copying files & directories ###
`cp` command = copies a file
	- check w `ls`
	- ==`% cp [old] [new]` = copies a file==

**Copy Files**
 `% cp quotes.txt thesis/quotations.txt`
`% ls quotes.txt thesis/quotations.txt`
	↳ this copies `quotes.txt` and paste it in `/thesis` and name it `quotations.txt`
	↳ `ls` command can check the two files

**Copy Directories**
`% cp -r thesis thesis_backup`
- `-r` option → recursive = backs up a directory
∴ `thesis` directory has been `-r` (copied) to a new directory called `thesis_backup` in the current directory
- `ls thesis thesis_backup` can be used to check the results
- `-r` is ALWAYS needed to copy a directory
	- if omitted, `-r not specified` msg pops up
### Operations w Multiple Files & Directories ###
- Copying/Moving several files at ONCE
	- by providing list of ind. filenames 
	- by specifying a naming pattern using WILDCARDS
		↳ special chars. represent unknown char OR sets of chars
	∴ `% cp minotaur.dat unicorn.dat basilisk.dat`
		- trying to copy a file into 3 file names doesn't work = shows ERROR
#### Using Wildcards for Accessing Multiple Files at Once ####
#### Wildcards ####
`*` = Wildcard
- represents zero or more other chars. 
- e.g `*.pdb` represents all files with an `.pdb` ending
	- `p*.pdb` represents files starting with `p` and has a `.pdb` ending

`?` = Wildcard
- represents EXACTLY one char.
- e.g. `?ethane.pdb` → could represent `methane.pdb`
- `*ethane.pdb` → can represent both `ethane.pdb` and `methane.pdb`

**Combination of Wildcards**
`???ane.pdb` → 3 unknown chars + `ane.pdb` = gives result of `cubane.pdb ethan.pdh octane.pdb`

When shell sees a wildcard = it expands results (list) first, then runs preceding commands
- shell expands the wildcards, NOT other programs

`-p` = option + path of one or more directories → `mkdir` to create any intermediate subdirectories as required
∴ `% mkdir -p 2016-05-20/data/raw`
`% mkdir -P 2016-05-20/data/processed`
↳ these commands will achieve both the main directory + subdirectories without having them in the first place
## SUGGESTED READING: Learn Enough Command Line to be Dangerous
**Michael Hartl**
*A tutorial introduction to the Unix command line*


# Setting up Git #

**Git** → popular ver. of control system 
**GitHub** → service to upload, host , manage code using Git

Github email : 219507106+ingrid-01@users.noreply.github.com
### Understanding SSH Key Pairs ###

- every SSH/SFTP connection = 4 keys (or 2 key pairs)