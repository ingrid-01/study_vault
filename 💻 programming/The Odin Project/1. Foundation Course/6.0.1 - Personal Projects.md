# 1. Button Click Counter #

0. Setup
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Button Counter</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Button Counter</h1>
  
	<!-- Counter Section -->
  <div class="counter">
	  <button id="clickMe">Click Me!</button>
	  <span id="count">0</span>
	  <button id="reset" type="button" disabled>Reset</button>
  </div>
  
	  <script src="script.js"></script>
</body>
</html>
```

- use of `<div>` container for counter elements
	- `<button id="clickMe">Click Me!</button>` - button users click
	- `<span id="count">0</span>` - shows the number of clicks
	- `<button id="reset" type="button" disable>Reset</button>` - resets the count; initially disabled

```css
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
body {
  font-family: Arial, sans-serif;
  text-align: center;
  margin-top: 50px;
}

.counter {
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 15px;
	margin-top: 20px;
}

button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
}

button:disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

#count {
	font-size: 20px;
	font-weight: bold;
}
```

1. Variables
```js
let count = 0;
```
Variable stores the number of clicks

2. DOM Selection
```js
const button = document.getElementById("clickMe");
const countSpan = document.getElementById("count");
```
Connects JS to HTML elements

getElementbyId was chosen instead of querySelector (although both do the same job) because:
- Direct and specific → only finds 1 element w the given `id`
- getElementbyId → slightly faster (browser has built-in lookup for IDs)

Rule of thumb:
- if I already have an id → use getElementById
- if I need flexibility (classes, nested selectors, first-of-type, etc.) → use querySelector or querySelectorAll
#### DOM ####
1. What is DOM?
- DOM = Document Object Model
- When browser loads an HTML file, it doesn't just "see text" - it builds a tree-like structure in memory
	- every element (e.g. `h1, button, p`) becomes a **node** (an object) in that tree
```html
<body>
  <h1>Hello</h1>
  <button>Click me</button>
</body>
```

Browser turns it into a DOM tree:
```css
Document
 └── <html>
      └── <body>
           ├── <h1>
           └── <button>
```
So the DOM is **the bridge** btw static HTMl & the live JS runtime

2. What is DOM selection
- "find an element inside the DOM tree and get a reference to it in JS"
- Once I have the reference = I can read it, change it, react to it
∴ Grabbing a handle to an HTML element → JS can work with

3. Why is this needed?
- W/O DOM selection, JS code lives in isolation - it doesn't "see" HTML page
- W DOM selection, I can:
	- change text of an element
	- change CSS styles dynamically
	- add new elements to the page
	- respond to user actions (click, type, hover)

4. Common DOM selection methods
```js
// Select by ID (only 1 element with that ID)
const title = document.getElementById("main-title");

// Select by class (returns a collection/array-like)
const buttons = document.getElementsByClassName("btn");

// Select by tag name
const paragraphs = document.getElementsByTagName("p");

// Modern, most common: querySelector (first match)
const header = document.querySelector("h1");

// Modern: querySelectorAll (all matches)
const allButtons = document.querySelectorAll("button");
```

5. Example in Action
```html
<h1 id="main-title">Hello</h1>
<button id="myButton">Click me</button>
```
```js
// Grab the button
const btn = document.getElementById("myButton");

// Grab the title
const title = document.getElementById("main-title");

// Add behavior: when user clicks button, change the title text
btn.addEventListener("click", function() {
  title.textContent = "You clicked the button!";
});
```

- Step 1: Browser builds DOM from HTML
- Step 2: JS "selects" (`getElementById`) the `<button>` and `<h1>`
- Step 3: JS attaches behaviour (click → change text)
- Step 4: Now HTML is no longer static - the page responds. 

∴ **DOM selection** = how JS gets into HTML page
w/o it, HTML stays frozen. 
w it, I can create interaction, dynamic styles, animation, games etc.

# Button Clicker cont. #

3. Event Listener
```js
button.addEventListener("click", function() {
	count = count + 1;
	countSpan.textContent = count;
})
```
Attach code to run when button is CLICKED

`addEventListener("click", ...)` → listen for clicks
`textContent` → update text on the page

`addEventListener` = method (a function built into DOM elements)
- *What is it?*
	- it's purpose = attach an event handler (a function that runs when something happens)
```js
const button = docutment.querySelector("button");

button.addEventListener("click", function() {
	alert("Button was clicked!");
})
```
- `button` = DOM element
- `.addEventListener("click", ...)` → tells the browser: "When user clicks on this button, run the given function"

- *How it works?*
	- using `addEventListener` = JS registers a listener w the browser's event system
		- It's like: 
			- I've ordered delivery and tell my brother to notify me when the order arrives. 
			- I don't keep stare at the door - instead, my brother listens for the event "delivery arrived" and notifies me
		- In JS:
			- browser = brother
			- event(`click, keydown, submit` etc.) is the thing I'm waiting for 
			- callback function is what you want to run once it happens
```js
// Syntax
element.addEventListener(eventType, callbackFunction);
```
- `eventType`: a string like `click, keydown, mouseover`
- `callbackFunction`: function to execute when the event happens

- *Why use it?*
	1. Separation of concerns: keeps JS beh. separate from HTML
```html
<!-- bad practice -->
<button onclick="alert('clicked')">Click Me</button>
```
vs.
```js
// good practice
button.addEventListener("click", () => alert("clicked"));
```

2. Multiple Listeners: you can attach more than one function to the same event
3. Flexibility: you can add, remove or modify listeners dynamically

- *When is it used?*
	- Whenever I want my WP to respond to **user interaction or browser events**: 
		- Button clicks (`"click"`)
		- Typing in a form (`"input", "keydown"`)
		- Page load (`"load"`)
		- Submitting a form (`"submit"`)
		- Mouse over (`"mouseover"`)

- JS "listens" = JS is waiting for a specific event to happen on a specific element
	- Once event happens = JS runs the attached function

# Cont. #
4. Refactor w Function
```js
function increaseCount() {
  count++;
  countSpan.textContent = count;
}

button.addEventListener("click", increaseCount);
```
- separating logic into a reusable function

This step pulls the click-handling code out of the anonymous function puts it into a named function, then hands that function to `addEventListener`. 
- This makes the code clearer, reusable, testable, and removable. 

## Before (inline handler) ##
```js
button.addEventListener("click", function() {
  count = count + 1;
  countSpan.textContent = count;
});
```
- an anonymous function is created + attached directly to the `click` event
- WORKS but → logic is inside the listener & can't be reused / easily removed

```js
function increaseCount() {
  count++;
  countSpan.textContent = count;
}

button.addEventListener("click", increaseCount);
```
**Step-by-step explanation**
1. `function increaseCount() {...}`
	- *Declaration* of `increaseCount`
	- a function declaration creates a reusable block of code I can call later
2. Inside the function:
	- `count++;`
		- Increments the `count` variable by 1. (Equivalent to `count = count + 1.)
		- Used as a standalone statement, the postfix `++` just changes the variable
	- `countSpan.textContent = count`; 
		- Updates the DOM: sets the visible text inside the `<span>` to the new `count`
3. `button.addEventListener("click", increaseCount);`
	- Passes the function itself (a reference) to `addEventListener`
	- Browser will call `increaseCount` each time the button is clicked
	- **important** = do NOT write `increaseCount()` here → that would call the function immediately & pass its return value instead of the function

## Refactor ##
- change the structure/organisation of code w/o changing what it does
- Goals: improve readability, reduce duplication, improve testability & maintainability
- I'm not adding a NEW beh., I am rewriting for clarity & reuse
### Practical benefits of refactoring this way ###
- **Reusability**: I can call `increaseCount()` from other places (another button, a keyboard shortcut, or tests)
- **Readability**: The name `increaseCount` documents intent better than an anonymous function
- **Debugging**: Stack traces show `increaseCount`, making errors easier to trace
- **Removal**: You can remove the listener later:
```js
button.removeEventListener("click", increaseCount);
```
-- This ONLY works if you passed a named/reference function. It doesn't work w an inline anonymous function because you have no reference to pass to `removeEventListener`

- **Testing**: You can call `increaseCount()` directly in the console or unit tests

### Alternatives and Notes ##
- Function expression (not hoisted):
```js
const increaseCount = () => {
	count++;
	countSpan.textContent = count;
};
button.addEventListener("click", increaseCount);
```
- This works the same at runtime; difference: function declarations are hoisted, function expressions are not
- If you used an anonymous function originally, you cannot remove it later because `removeEventListener` needs the same function reference
### Quick refactor Checklist (practical) ###
1. Identify repeated / important logic inside the inline handler
2. Cut it into a function w a clear name (`increaseCount`)
3. Replace the inline function in `addEventListener` w the function name (reference)
4. Test clicking the button - beh. must be unchanged
5. Optionally reuse the function elsewhere or remove the listener when needed. 
# Cont. #
6. Extension Challenge - with Reset Button
	1. Select Elements
```js
const clickButton = document.getElementByID("clickMe");
const resetButton = document.getElementByID("reset");
const countSpan = document.getElementByID("count");
```
- `document.getElementById("clickMe")` → finds element w ID `clickMe` in HTML
- We store it in a variable `clickButton` so we can use it later
- Same for the reset button and the `<span>` that shows the count

	2. Initialise Counter
```js
let count = 0;
```
- `count` stores how many times the button has been clicked
- Starts at 0

	3. Update Display
```js
function updateDisplay() {
	countSpan.textContent = count;
	resetButton.disabled = count === 0;
}
```
- `countSpan.textContent = count` → changes the number on the page
- `resetButton.disabled = count === 0` → disables reset if count is 0, enables it otherwise

	4. Event Listeners
```js
clickButton.addEventListener("click", function () {...})
```
- `addEventListener("click", ...)` → run a function when the button is clicked
- Inside the function:
	- Increase count (`count++`)
	- Update the display (`updateDisplay())
- Similarly for reset button: set count to 0 and update display

Hence:
```js
const clickButton = document.getElementById("clickMe");
const countSpan = document.getElementById("count");
const resetButton = document.getElementById("reset");

let count = 0;

function updateDisplay() {
countSpan.textContent = count;
resetButton.disabled = count === 0;
}

clickButton.addEventListener("click", function () {
count++;
updateDisplay();
});

resetButton.addEventListener("click", function () {
count = 0;
updateDisplay();
});
```
### Why updateDisplay() was used instead of countSpan.textContent ###

**Case 1: W/O `updateDisplay()`**
```js
clickButton.addEventListener("click", function() {
	count++;
	countSpan.textContent = count;
	resetButton.disabled = count === 0;
});

resetButton.addEventListener("click", function() {
	count = 0;
	countSpan.textContent = count;
	resetButton.disabled = count === 0;
});
```

notice the line:
```js
countSpan.textContent = count;
resetButton.disabled = count === 0;
```
are **repeated** in BOTH places

∴ if we ever change how the display works (e.g. make the number red if it's above 10), we'd have to change it in **two places**

→ BAD for maintainability

**Case 2: W `updateDisplay()`**
```js
function updateDisplay() {
	countSpan.textContent = count;
	resetButton.disabled = count === 0;
}

clickButton.addEventListener("click", function() {
	count++;
	updateDisplay();
});

resetButton.addEventListent("click", function() {
	count = 0;
	updateDisplay();
});
```

Now:
- All logic for HOW DISPLAY UPDATES is in one function
- Both the click handler & reset handler just call it
- If we CHANGE the display logic later (color, font size, extra text) we only update ONE PLACE

THIS FOLLOWS the basic programming principle:
DRY = Don't Repeat Yourself

Instead of duplicating the same code in multiple places, you "factor it out" into a function. That way:
- Code is shorter,
- Easier to read,
- Easier to maintain