# Introduction to Git #

**Git** = EPIC SAVE BUTTON for files & directories
- WHY?
	- Text editor 'save' = all the words in a doc, in a single file
		- so 1 record of the file
			- e.g. `essay.doc` unless duplicated → `essay-draft1.doc`, `essay-draft2.doc`, `essay-final.doc`
	- Git 'save' = records differences in files & folders AND keep a **historical record of each save**
		- enables full review of ongoing project 
			- can keep track of the growth + can easily restore file states from the past
			- When connected to a network, Git allows push my project to GitHub or other alternatives
				- e.g. Bitbucket, Beanstalk, GitLab

- Git works on *local* machine
- Github → remote storage
∴ learning Git = showcase my portfolio on GitHub!!!
## READING: Getting Started - Git ##
### Version Control ###
- "Version Control" → system that records changes to a file (or a set of files) over time 
	- can recall specific ver. later
		↳ Useful as a web designer = need to keep every ver. of imgs and layout = "Version Control System" (VCS)
	- ALSO easy recovery system
#### Local Ver. Control System ####
- Should have a simple database to keep all the changes to files under revision control 
*E.g.*
![[Pasted image 20250712172008.png]]
↳ Most popular VCS = RCS (revision control system)
- works by keeping patch sets (the difference btw files) in a special format on disk
#### Centralised Ver. Control Systems ####
- Needing to collaborate w devs on other systems? 
	- use CVCSs (Centralised Version Control Systems)
		- have a SINGLE server containing ALL the versioned files + a number of clients that check out files from the central place
![[Pasted image 20250712172606.png]]
↳ Everyone knows to a certain degree what everyone else on the project is doing
- BUT -ves: 
	- single point of failure that centralised server represents
		- IF server goes down an hour, nobody can collaborate + can't save what they've been working on
		- IF central database is corrupted + no backups = LOST EVERYTHING
			- same with Local VCS, if only saved in ONE place
#### Distributed Ver. Control Systems ####
- DVCSs (Distributed Version Control Systems)
	-  e.g. Git, Mercurial, Darcs
	- these can: check out latest snapshot of each files (not fully mirrored repository) + incl. full history
		- IF server dies → any of the client's repositories that has been collab-ing with, be copied back to server to restore
![[Pasted image 20250712173413.png]]
- can collaborate simultaneously within the same project
	- can set up several types of workflows 
		- NOT POSSIBLE on CVCSs
### A short History ###
- During early Linux kernel maintenance (1991-2002), DVCS called BitKeeper was in use
- 2005, broke down 
	- so Linux dev community developed own tool 
		- considered: Speed, simple design, strong support for non-linear dev (thousands of parallel branches), Fully distributed, can handle lrg projects (speed & data size IMPORTATNT!!!)
### What is Git? ###
#### Snapshots, Not differences ####
- **Git** →  thinks about its data (diff. to other VCSs)
	- Most systems store info as **List of file-based changes**
		- ==delta-based version control==
![[Pasted image 20250712175041.png]]
↳ Storing data as CHANGES to a BASE VER. of each file

Git doesn't do this
- Git thinks data as **series of snapshots**
	- makes it like mini filesystem
#### Nearly Every Operation is Local ####
- Git doesn't need to leave current server
	- it reads from my local database
		- Can see the project history almost instantly
	- Can work on the project anywhere, anytime
		- just need internet connection when uploading
#### Git has Integrity ####
- Everything is checksummed before stored & referred to by that checksum
	∴ impossible to change the contents of any file/directory w/o GIt knowing about it
		Git knows EVERYTHING!!!
		- You can't lost info in transit + get file corruption w/o Git being able to detect it
- Checksumming → SHA-1 hash (40 char string of hexadecimal chars) is calculated based on contents of file/directory
	- e.g. `24b9da6552252987aa493b52f8696cd6d3b00373`
	- Git stores everything by hash value of its content
#### Git Generally Only Adds Data ####
3 states of Git:
1. Modified (Working Directory)
	- when changing file but not committed to DB yet
2. Staged
	- marked modified file in its current ver. to go into my next commit snapshot
3. Committed
	- data is safely stored in my local DB
![[Pasted image 20250712182527.png]]
↳ the working tree → single checkout of one ver. of the project
- for use and to modify - Git directory

Staging → stores info = a.k.a. "index" - Git directory

Git Directory → metadata & object database (most important!!); 

**Git Workflow**
1. I modify files on working tree
2. selectively stage those changes → adds only those changes to the staging area
3. Commit = stores the files in the staging area permanently
# Git Basics #

1. Set up new repository through GitHub
2. Click green "Code" to copy/clone this repository onto local machine
	- MUST select SSH option 
3. On local machine command line, `git clone [SSH URL]`
4. To test = `cd` into the chosen folder + `git remote -v` which will show my GitHub username
	- shows fetch (address Git uses to dwnld updates from remote repository - new commits, branches etc.) & push (address Git uses to upload my commits to the remote repository) URLS
## Cheatsheet ##
**Most Common Git Commands**

- Remote Repository
	- `git clone git@github.com:ingrid-01/git_test.git`
		- start working on ↑ this repository
	- `git push` or `git push origin main` 
		- "upload" it to GitHub

- Workflow
	- `touch hello_wold.txt`
		- adds a new file to the depository → "untracked file"; not staged yet
	- `git add .` (add ALL files in the current directory) or `git add [helow_world.txt]` (add a specific file)
		- adds a new file to the staging area
	- `git commit -m "[msg describing what you have done to make this snapshot different]"`
		- e.g. `git commit -m "Add hello_world.txt"`
		- `git commit -m "Edit README.md and hello_world.txt`
			- "save" to local file

- Can use VScode to modify the files - `code .`
- use Ctrl + backtick → to use terminal thorugh VScode

- Check status / log history
	- `git status`
	- `git log`

Git syntax : `[program] [action] [destination]`
E.g.
- `git add .` = `[git] [add] [.]`
- `git commit -m "message"` = `[git] [commit -m] ["message"`
	- OR after configuration `git config --global core.editor "code --wait"`
		- `git commit` will suffice (currently working on my VS code!)
- `git status` = `[git] [status] [no destination]`
## Atomic Commits ##
- Atomic Commit = commit for only ONE feature or task of my program

- This is helpful because:
	1. easy to revert the specific change
	2. enables me to write better commit msgs. 